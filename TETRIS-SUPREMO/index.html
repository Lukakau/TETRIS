<!DOCTYPE html>
<html lang="PT-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"> <!--Collapse-->
    <link rel="stylesheet" href="https://cdn.datatables.net/2.0.0/css/dataTables.dataTables.css"> <!--Datatable-->
    <style>
        :root{ 
            --corPagina: rgb(0, 4, 255);  ;
        }
        *{ 
            margin: 0;
            box-sizing: border-box;
        }
        @font-face {
            font-family: Arcade_I;
            src: url(/fonts/ARCADE_I.TTF);
        }
        @font-face {
            font-family: Arcade_N;
            src: url(/fonts/ARCADE_N.TTF);
        }
        @font-face {
            font-family: Arcade_R;
            src: url(/fonts/ARCADE_R.TTF);
        }
        body{  
            background: black;
            font-family: Arcade_N;  
            font-size: 18px;
        }  
        .tudo{
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            margin-top: 40px;
            
        }
        #tetris{  
            border: solid 0.2em var(--corPagina);  
            height: 90vh;
        }  
        #nextPiece{
            border: solid 0.2em var(--corPagina);  
            height: 25vh;
        }
        #comandos{
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            height: 50px;
            cursor: pointer;
            width: 150px;
            outline: none;
        }
        #salas{
            display: flex;
            align-items: center;
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            height: 50px;
            cursor: pointer;
            width: 150px;
            outline: none;
        }
        #comandos-box {
            left: 50%;
            font-size: 10px;
            display: none;
            position: relative;
            background-color: #020202;
            color: white;
            border: 2px solid white;
            border-radius: 5px;
            transform: translateX(-50%);
        }
        .botoes{
            display: flex;
            flex-direction: column;
            gap: 30px;
            align-items: center;
        }
        #startButton{
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            height: 50px;
            cursor: pointer;
            width: 150px;
            outline: none;
            display: flex;
            align-items: center;
        }
        #gameOverScreen {
            display: none;
            position: fixed;
            text-align: center;
            top: 43%;
            left: 50.5%;
            transform: translate(-50%, -50%);
            color: white;
        }
        #logo{
            height: 150px;
        }
        .cartao{
            font-size: 14px;
            width: 217px;
            position: relative;
            background-clip: border-box;
            color: var(--corPagina);
            text-align: center;
        }
        #score{
            color: var(--corPagina);  
        }
        #botao-score{
            display: flex;
            align-items: center;
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            height: 50px;
            cursor: pointer;
            width: 150px;
            outline: none;   
        }
        .corpo-modal{
            display: flex;
            align-items: center;
            justify-content: center;
        }
        @media (min-width: 576px){
        .modal-dialog {
            max-width: 1227px;
            margin: 1.75rem auto;
            padding-block-end: 10px;
        }}
        @media (min-width: 576px){
        .modal-dialog {
            padding: 80px;
        }}
        .modal-content {
            color: var(--corPagina);  
            position: relative;
            display: -webkit-box;
            display: -ms-flexbox;
            display: flex;
            -webkit-box-orient: vertical;
            -webkit-box-direction: normal;
            -ms-flex-direction: column;
            flex-direction: column;
            width: 100%;
            pointer-events: auto;
            background-color: #ffffff;
            background-clip: padding-box;
            border: 1px solid rgba(0,0,0,.2);
            border-radius: 0.3rem;
            outline: 0;
            padding: 37px;
        }
        #leftside{
            display: flex;
            flex-direction: column;
            gap: 30px;            
        }
        #canva-score{
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        table.dataTable thead th, table.dataTable thead td, table.dataTable tfoot th, table.dataTable tfoot td {
        text-align: center;
        }
        table.dataTable th.dt-type-numeric, table.dataTable th.dt-type-date, table.dataTable td.dt-type-numeric, table.dataTable td.dt-type-date {
        text-align: center;
        }
        .botao-de-exclusao{
            height: 25px;
            width: 25px;
            border: none;
            background: linear-gradient(68.15deg, #4c92ad 16.62%, #9cc5c7 85.61%);
            background-image: url(/img/icone-fermer-et-x-rouge.png);
            background-size: cover;
            cursor:pointer
        }
        #nivel{
            color: var(--corPagina);
        }
        #rightSide{
            display: flex;
            align-items: center;
            gap: 30px;
        }
    </style>
</head>
<body>
    <div class="tudo"> <!--Div englobando tudo-->
        <div id="gameOverScreen" style="display: none;"> <!--Tela de Game Over fica hidden at√© o gatilho ser ativo-->
            <h1>Game Over!</h1>
        </div>
        <div id="leftside">  <!--Div englobando a parte esquerda com os bot√µes, score, etc-->
            <div id="canva-score" style="display: none;">
                <div id="score"></div>
                <div id="nivel"></div>
            </div>
            <img src="/img/tetris-logo.png" id="logo"> <!--Logo do jogo-->
            <div class="botoes">
                <button onclick="start(), buttonClickSound()" id="startButton">Single Player</button>
                <!-- Button trigger modal -->
                <button type="button" id="salas" data-toggle="modal" data-target="#exampleModal">
                    Multi Player
                </button>
                <!-- Modal -->
                <div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                            <h5 class="modal-title" id="exampleModalLabel">Deseja Criar Uma Sala?</h5>
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                                <span aria-hidden="true">&times;</span>
                            </button>
                            </div>
                            <div class="modal-body">
                            Voce precisa de um amigo na mesma rede para jogar um jogo 1 contra 1.
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-dismiss="modal">Nao</button>
                                <button type="button" class="btn btn-primary">Criar Sala</button>
                            </div>
                        </div>
                    </div>
                </div>
                <button onclick= "buttonClickSound()" id="comandos" data-toggle="collapse" data-target="#collapseExample" aria-expanded="false" aria-controls="collapseExample"> <!--Func "buttonClickSound respons√°vel pelo som de click do mine"-->
                    Comandos
                </button>
                <div class="collapse" id="collapseExample"> <!--Collapse com os comandos-->
                    <div class="cartao">
                        < >: Mover<br>
                        ü°£: Descer<br>
                        A: Sentido Anti-Horario<br>
                        D: Sentido Horario<br>
                        Espaco: Hard Drop
                    </div>
                </div>
                <button onclick= "buttonClickSound()" type="button" id="botao-score" data-toggle="modal" data-target=".bd-example-modal-lg"> <!--Modal com scoreboard-->
                    Score Board
                </button> 
                <div class="modal fade bd-example-modal-lg" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel" aria-hidden="true">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <table id="example" class="display" style="width:100%">
                                <thead>
                                    <tr>
                                        <th>Nome</th>
                                        <th>Sobrenome</th>
                                        <th>Level</th>
                                        <th>Score</th>
                                        <th>Data</th>
                                        <th>Excluir</th>
                                    </tr>
                                </thead>
                                <tbody id="scoreboardBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="rightSide" style="display: none;">
            <canvas id="tetris" width="240" height="400"></canvas> <!--Canvas principal com o jogo-->
            <canvas id="nextPiece" width="80" height="80"></canvas> <!--Quadrado com prox pe√ßa-->
        </div>
    </div>

    <!--Audios utilizados-->

    <audio id="gameOverSound" src="/audios/Arcade retro game over sound effect (FREE)_gdrQrCOSFfI.mp3"></audio>
    <audio id="tetrisDropSound" src="/audios/minecraft-item-drop-sound-effect-pgpbe9afed4_YItRJKGt.mp3"></audio>
    <audio autoplay id="tetrisBackgroundMusic" src="/audios/Animal Crossing_ City Folk- 2 AM_YsDM3UvXWOc.mp3" loop></audio>
    <audio id="buttonSound" src="/audios/button-plate-click-minecraft-sound-sound-effect-for-editing-h8y0jmvwdmm_F41koB79.mp3"></audio>
    <audio id="lineClear" src="/audios/tetris-game-boy-line-clear-sound-effects-lddsf4szgjw_S9wGjWBw.mp3"></audio>

    <script src="https://code.jquery.com/jquery-3.7.1.js"></script> <!--Importa√ß√£o do Jquery-->
    <script src="//cdn.datatables.net/2.0.0/js/dataTables.js"></script> <!--Datatale-->

    <!--Script Respons√°vel pela inicia√ß√£o da Datatable-->

    <script>
        let scoreboardTable;
        $(document).ready(function() {
            scoreboardTable = $('#example').DataTable({ 
                order: [ // Ordena√ß√£o da datatable com base em score, level, data e nome //
                    [3, 'desc'],
                    [2, 'desc'],
                    [4, 'asc'],
                    [0, 'asc'],
                ]
            });
            loadScoreboardData(); // Carregamos as informa√ß√µes salvas no dispositivo assim que carrega a datatable //
        });
    </script>

    <!--Mais importa√ß√µes de collapse e modal-->

    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous">
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous">
    </script>

    <!--C√≥digo Principal do jogo-->

    <script>
        "use strict"; //Preven√ß√£o de erros de sintaxe, etc//
        document.addEventListener('DOMContentLoaded', function() {
        const tetrisBackSound = document.getElementById('tetrisBackgroundMusic'); //Adi√ß√£o do som de fundo//
            tetrisBackSound.addEventListener('loadedmetadata', function() {
                tetrisBackSound.volume = 0.7
                tetrisBackSound.play();
            });
        });
        const buttonClick = document.getElementById('buttonSound');
        const gameOverSound = document.getElementById('gameOverSound');
        const tetrisDrop = document.getElementById('tetrisDropSound');
        const clearSound = document.getElementById('lineClear');
        const botaoStart = document.getElementById('startButton');
        const canvas = document.getElementById("tetris"); // Achamos o canvas //
        const context = canvas.getContext("2d"); // Definimos ele como 2d atrav√©s do context//
        context.scale(20, 20); // Passamos uma escala pra esse contexto //

        function arenaSweep() {   // Fun√ß√£o respons√°vel por limpar as linhas da arena e contabilizar pontos //
            let rowCount = 1;  // Definimos a contagem das linhas em 1, √© respons√°vel por saber quantas linhas foram removidas de uma vez //
            outer: for (let y = arena.length - 1; y > 0; --y) { // Outer √© um comando que permite que voc√™ de "break" em um loop externo utilizando um loop interno. Esse loop √© respons√°vel por percorrer as linhas e c√©lulas da arena, come√ßando da ultima e indo ate a primeira. //
                for (let x = 0; x < arena[y].length; ++x) {  // Aqui no caso, atravessa as c√©lulas da linha atual. //
                    if (arena[y][x] === 0) {  // Se o valor das posi√ß√µes x e y for 0, ele continua com a verifica√ß√£o ignorando a linha atual
                        continue outer;  
                    }  
                }
                const row = arena.splice(y, 1)[0].fill(0); // Caso a linha inteira esteja preenchida com 0, ela √© repreenchida com 0, assim, limpando a linha //
                arena.unshift(row); // Agora, essa mesma linha √© adicionada a parte decima da arena, fazendo com que as outras linhas venham pra baixo
                ++y; // O ++y √© respons√°vel por pular a linha impedindo que o looping externo limpe a linha novamente (causando um bug) //
                lineClearSound(); // Sonzinho pra quando limpar a linha //
                player.score += rowCount * 10; // O score do jogador √© a quantia de linhas que ele quebrou * 10, se ja houver score anterior, √© somado ao score "novo" que o jogador fez. Exemplo: eu quebrei 2 linhas, esse valor vai ser multiplicado por 10, dito isso, 2x10 = 20. esse valor vai ser multiplicado por 3 na pr√≥xima linha do c√≥digo, dito isso, se eu quebrar mais linhas, (at√© um m√°ximo de 4), mais pontos eu fa√ßo. //
                rowCount *= 3;  
            }  
        }  
        function collide(arena, player) {  // Fun√ß√£o para verificarmos a colis√£o da pe√ßa do jogador com as paredes, fundo da arena ou com outras pe√ßas. //
            const m = player.matrix; // Definimos M como a matriz do jogador (pe√ßa atual) //
            const o = player.pos; // Definimos O como a posi√ß√£o atual do jogador //
            for (let y = 0; y < m.length; ++y) { // Looping externo respons√°vel por verificar se no eixo Y, ir√° haver colis√£o //
                for (let x = 0; x < m[y].length; ++x) { // Mesma coisa para o eixo X //
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {  // Este if √© respons√°vel por verificar se os valores de X e Y do jogador e da arena s√£o diferentes de zero, levando em considera√ß√£o de que ambos s√≥ ser√£o considerados colididos caso estejam no mesmo espa√ßo da matriz. //
                        return true; // Retorna true caso tenha 2 valores diferentes de 0 no mesmo espa√ßo //
                    }  
                }  
            }  
            return false;
        }  
        function createMatrix(w, h) {  // Fun√ß√£o para criar a matrix do jogo de acordo com a altura e largura desejados. Nada muito complexo //
            const matrix = []; // A matrix √© definida como uma array vazia //
            while (h--) {  // Enquanto a altura estiver diminuindo, ele continau preenchendo a matrix com "0" //
                matrix.push(new Array(w).fill(0));
            }  
            return matrix; // Dito isso, agora a fun√ß√£o retorna a matrix como uma array preenchida com "0" em toda a sua altura e largura. //
        }  
        function createPiece(type) {  // Fun√ß√£o para a cria√ß√£o das pe√ßas //
            if (type === "I") {  
                return [ // Brinque como quiser com o formato dessas pe√ßas KASKASKKAS //
                    [0, 1, 0, 0],  
                    [0, 1, 0, 0],  
                    [0, 1, 0, 0],  
                    [0, 1, 0, 0],  
                ];  
            } else if (type === "L") {  
                return [  
                    [0, 2, 0],  
                    [0, 2, 0],  
                    [0, 2, 2],  
                ];  
            } else if (type === "J") {  
                return [  
                    [0, 3, 0],  
                    [0, 3, 0],  
                    [3, 3, 0],  
                ];  
            } else if (type === "O") {  
                return [  
                    [4, 4],  
                    [4, 4],  
                ];  
            } else if (type === "Z") {  
                return [  
                    [5, 5, 0],  
                    [0, 5, 5],  
                    [0, 0, 0],  
                ];  
            } else if (type === "S") {  
                return [  
                    [0, 6, 6],  
                    [6, 6, 0],  
                    [0, 0, 0],  
                ];  
            } else if (type === "T") {  
                return [  
                    [0, 7, 0],  
                    [7, 7, 7],  
                    [0, 0, 0],  
                ];  
            }  
        }  
        function drawMatrix(matrix, offset) { // Esta fun√ß√£o √© respons√°vel por dar cor as pe√ßas e desenhar elas no campo, mas ela s√≥ ser√° chamada daqui a pouco //
            matrix.forEach((row, y) => {  
                row.forEach((value, x) => {  
                    if (value !== 0) { // Aqui passamos por cada valor diferente de 0 no eixo X e Y de uma pe√ßa, dito isso, caso o valor seja diferente de "0", ("1","2","3", etc) a fun√ß√£o pinta a c√©lula de acordo com a pe√ßa. (Caso seja "1", "2" e assim por diante). //
                        const gradient = context.createLinearGradient(x + offset.x, y + offset.y, x + offset.x + 1, y + offset.y + 1);
                        switch(value) {
                            case 1: // Pe√ßa I (Vermelho neon)
                                gradient.addColorStop(0, '#FF3E4D');
                                gradient.addColorStop(1, '#FFA07A');
                                break;
                            case 2: // Pe√ßa L (Azul neon)
                                gradient.addColorStop(0, '#00FFFF');
                                gradient.addColorStop(1, '#6A5ACD');
                                break;
                            case 3: // Pe√ßa J (Verde neon)
                                gradient.addColorStop(0, '#39DF14');
                                gradient.addColorStop(1, '#000F7F');
                                break;
                            case 4: // Pe√ßa O (Amarelo neon)
                                gradient.addColorStop(0, '#FFFF00');
                                gradient.addColorStop(1, '#FF6700');
                                break;
                            case 5: // Pe√ßa Z (Roxo neon)
                                gradient.addColorStop(0, '#BF04FF');
                                gradient.addColorStop(1, '#0122CC');
                                break;
                            case 6: // Pe√ßa S (Rosa neon)
                                gradient.addColorStop(0, '#FF1493');
                                gradient.addColorStop(1, '#FF69B4');
                                break;
                            case 7: // Pe√ßa T (Laranja neon)
                                gradient.addColorStop(0, '#FFA500');
                                gradient.addColorStop(1, '#FF4500');
                                break;
                        }
                        context.fillStyle = gradient;
                        context.fillRect(x + offset.x, y + offset.y, 1, 1);
                        context.fillStyle = 'rgba(255, 255, 255, 0.05)';
                        context.fillRect(x + offset.x, y + offset.y, 1, 1);
                    }  
                });  
            });  
        }

        function drawNextPiece(piece) { // Fun√ß√£o respons√°vel por criar o quadradinho que mostra a proxima pe√ßa (e j√° mostrar ela como consequ√™ncia) //
            const canvasNextPiece = document.getElementById("nextPiece");
            const contextNextPiece = canvasNextPiece.getContext("2d"); // Definimos o mesmo contexto de 2d, mas dessa vez n√£o damos os par√¢metros anteriores de 20x20 //

            contextNextPiece.clearRect(0, 0, canvasNextPiece.width, canvasNextPiece.height); // Esta linha da clear no quadradinho para previnir que n√£o haja alguma pe√ßa ali e quando a outra aparecer, n√£o acabar sobrescrevendo a anterior //

            const cellSize = canvasNextPiece.width / 5; // Definimos um quadradinho de "5x5" //
            const offsetX = (canvasNextPiece.width - piece[0].length * cellSize) / 2; // Estas duas linhas s√£o respons√°veis pela localiza√ß√£o da pe√ßa no quadradinho, se vai ser no centro ou onde der pra ajustar //
            const offsetY = (canvasNextPiece.height - piece.length * cellSize) / 2; 
            piece.forEach((row, y) => { // Aqui fazemos a mesma coisa da func anterior para dar cor as pe√ßas que ir√£o aparecer //
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const gradient = contextNextPiece.createLinearGradient(x * cellSize + offsetX, y * cellSize + offsetY, (x + 1) * cellSize + offsetX, (y + 1) * cellSize + offsetY);
                        switch (value) {
                            case 1: // Pe√ßa I (Vermelho neon)
                                gradient.addColorStop(0, '#FF3E4D');
                                gradient.addColorStop(1, '#FFA07A');
                                break;
                            case 2: // Pe√ßa L (Azul neon)
                                gradient.addColorStop(0, '#00FFFF');
                                gradient.addColorStop(1, '#6A5ACD');
                                break;
                            case 3: // Pe√ßa J (Verde neon)
                                gradient.addColorStop(0, '#39DF14');
                                gradient.addColorStop(1, '#000F7F');
                                break;
                            case 4: // Pe√ßa O (Amarelo neon)
                                gradient.addColorStop(0, '#FFFF00');
                                gradient.addColorStop(1, '#FF6700');
                                break;
                            case 5: // Pe√ßa Z (Roxo neon)
                                gradient.addColorStop(0, '#BF04FF');
                                gradient.addColorStop(1, '#0122CC');
                                break;
                            case 6: // Pe√ßa S (Rosa neon)
                                gradient.addColorStop(0, '#FF1493');
                                gradient.addColorStop(1, '#FF69B4');
                                break;
                            case 7: // Pe√ßa T (Laranja neon)
                                gradient.addColorStop(0, '#FFA500');
                                gradient.addColorStop(1, '#FF4500');
                                break;
                        }
                        contextNextPiece.fillStyle = gradient;
                        contextNextPiece.fillRect(x * cellSize + offsetX, y * cellSize + offsetY, cellSize, cellSize);
                        contextNextPiece.fillStyle = 'rgba(255, 255, 255, 0.05)';
                        contextNextPiece.fillRect(x * cellSize + offsetX, y * cellSize + offsetY, cellSize, cellSize);
                    }
                });
            });
        }
        
        // Duas func de som que t√£o meio perdidas ai //

        function buttonClickSound(){
            buttonClick.play();
        }
        
        function lineClearSound(){
            clearSound.play();
        }

        function draw() {  // Func respons√°vel por fazer o fundinho da arena //
            context.fillStyle = "#000"; // Definimos o fundinho como preto (experimenta por rosa pra vc ver que engra√ßado) //
            context.fillRect(0, 0, canvas.width, canvas.height); // Colocamos essa cor em toda a exten√ß√£o do canva //
            drawMatrix(arena, {x: 0, y: 0}); // Coloca√ß√£o da pe√ßa em campo no local (arena) e posi√ß√£o que queremos. //
            drawGhostPiece(); // Optei por colocar a fun√ß√£o de ghostpiece aqui pois assim que surge alguma pe√ßa, j√° √© identificada qual pe√ßa √© e em qual posi√ß√£o ela est√° com base no offset (posi√ß√£o) dela. Mais tarde essa fun√ß√£o vai ser melhor explicada //
            drawMatrix(player.matrix, player.pos); // Chamamos novamente a draw matrix para a matriz e para a posi√ß√£o atual do jogador, definida no final do c√≥digo //
        }  
        function merge(arena, player) {  // Fun√ß√£o para integrar a pe√ßa ao campo, junto a matriz e as outras pe√ßas do jogador //
            player.matrix.forEach((row, y) => {  
            row.forEach((value, x) => {  
                if (value !== 0) {  // Percorremos novamente por cada linha e em cada c√©lula verificando se o valor √© diferente de 0. Se for, ele define que essa posi√ß√£o atual da pe√ßa agora ser√° o novo valor nas posi√ß√µes x e y tanto da arena quanto do jogador. //
                arena[y + player.pos.y][x + player.pos.x] = value;  
                }  
            });  
        });  
        }  
        function rotate(matrix, dir) { // Func respons√°vel por rotacionar a pe√ßa //
            for (let y = 0; y < matrix.length; ++y) { 
                for (let x = 0; x < y; ++x) { 
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; // Dentro do loop, os elementos s√£o trocados de posi√ß√£o, ent√£o, o que era x vira y e o que era y vira x (bem confuso) // 
                }  
            }  
            if (dir > 0) { // Se o valor for positivo, rotaciona em sentido hor√°rio, se for negativo, rotaciona no inverso (anti-hor√°rio) //
                matrix.forEach((row) => row.reverse());  
            } 
            else {  
                matrix.reverse();  
            }  
        } 
        function playerDrop() { // Func para a pe√ßa simplesmente cair //
            player.pos.y++;
            if (collide(arena, player)) { // Se colidir com alguma coisa enquanto estiver caindo: volta 1 posi√ß√£o do eixo y para que a pe√ßa n√£o fique dentro da outra. Irei tentar explicar por texto como funciona a colis√£o: Se a pe√ßa entrar dentro da arena ou de outra pe√ßa (cujos valores s√£o diferentes de 0), a func collide retorna o valor true, dizendo que ali houve colis√£o de dois corpos. //
                player.pos.y--; // Dito isso, agora volta 1 posi√ß√£o //
                merge(arena, player); // Integra a posi√ß√£o daquela pe√ßa a arena fazendo com que fique "fixa" ali //
                playerReset(); // Faz uma nova pe√ßa aparecer no campo //
                arenaSweep(); // Chama a fun√ß√£o que percorre a arena para verificar se houve uma linha inteira preenchida com valor diferente de 0, se houver, j√° limpa e conta a pontua√ß√£o //
                updateScore(); // Atualiza o score do jogador //
            }
            dropCounter = 0; // Define tamb√©m a contagem de "dropagem" (n√£o consigo pensar em outro termo) em 0. //
        }
        function playerMove(offset) {  // Fun√ß√£o para mover a pe√ßa do jogador. //
            player.pos.x += offset;  // Posi√ß√£o no eixo X do jogador somada a posi√ß√£o passada no par√¢metro //
            if (collide(arena, player)) {  // Se colidir, o eixo X do jogador √© impedido de progredir pois sempre ser√° subtraida pela posi√ß√£o //
                player.pos.x -= offset;  
            }  
        }  

        let shuffledPieces = shufflePieces(); // Definimos uma vari√°vel com as pe√ßas embaralhadas //

        function shufflePieces() { // Func para embaralhar as pe√ßas (balancear o jogo) //
            const pieces = "TJLOSZI".split(''); // Pegamos todas as pe√ßas e dividimos todas em strings √∫nicas //
            // Embaralhe as pe√ßas usando o algoritmo de Fisher-Yates //
            for (let i = pieces.length - 1; i > 0; i--) { // Looping para sempre pegar pe√ßas diferentes e nunca repetir duas pe√ßas seguidas //
                const j = Math.floor(Math.random() * (i + 1)); // Faz aquela parada maluca do fisher-yates que nao sei explicar //
                [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
            }
            return pieces; // Retorna essas pe√ßas agora embaralhadas //
        }
        const pieceFrequency = { // Define que cada uma das pe√ßas agora tem um valor inicial de "0", que logo ser√° aumentado //
            "T": 0,
            "J": 0,
            "L": 0,
            "O": 0,
            "S": 0,
            "Z": 0,
            "I": 0
        };
        function playerReset() { // Fun√ß√£o que faz a pe√ßa aparecer no campo //
            const selectedPiece = shuffledPieces.pop(); // Pegamos a pe√ßa que ir√° aparecer e dizemos que essa pe√ßa ser√° a √∫ltima pe√ßa do array de pe√ßas embaralhadas // 
            
            drawNextPiece(createPiece(shuffledPieces[shuffledPieces.length - 1])); // aqui dizemos que a pr√≥xima pe√ßa a aparecer no quadradinho de pr√≥ximas pe√ßas, ser√° o valor das pe√ßas embaralhadas - 1, dito isso, ser√° uma pe√ßa depois da pe√ßa atualmente em campo. //
            
            player.matrix = createPiece(selectedPiece); // Criamos a pe√ßa com a pe√ßa j√° escolhida das pe√ßas embaralhadas //
            player.pos.y = 0; // Definimos que ela ir√° aparecer nesta posi√ß√£o do eixo Y e X //
            player.pos.x = Math.floor((arena[0].length / 2) - (player.matrix[0].length / 2));
            
            if (collide(arena, player)) { // Se agora a pe√ßa do jogador colidir com a nova pe√ßa desenhada, ser√° retornada a fun√ß√£o de gameOver, que para o jogo, j√° j√° chegamos nela. //
                gameOver(player.level);
                return;
            }
            pieceFrequency[selectedPiece]++; // Aqui aumentamos a frequ√™ncia de pe√ßas daquela array anterior que definimos como 0, essa frequ√™ncia ser√° adicionada com base na pe√ßa selecionada atualmente, fazendo com que sempre haja esse balanceamento correto das pe√ßas //

            shuffledPieces.unshift(selectedPiece); // Faz com que a pe√ßa selecionada seja adicionada ao array de pe√ßas embaralhadas na √∫ltima posi√ß√£o, fazemdo com que haja uma fila que ser√° sempre reembaralhada //
        }

        function playerRotate(dir) {  // Func que ir√° rotacionar a pe√ßa //
            const pos = player.pos.x; // Definie a posi√ß√£o como a posi√ß√£o X do jogador para caso n√£o seja poss√≠vel rotacionar, sendo assim, volta a posi√ß√£o original //
            let offset = 1; // Define a posi√ß√£o offset como 1 //
            rotate(player.matrix, dir); // Chama a func rotate com os par√¢metros da pe√ßa do jogador e em qual posi√ß√£o ele ir√° rotacionar (positiva ou negativa)
            while (collide(arena, player)) { // Definimos um loop para caso a pe√ßa esteja colidindo com algum elemento //
                player.pos.x += offset; // Basicamente nas linhas abaixo, os valores s√£o verificados para compreender se ser√£o positivos ou negativos. Caso haja um valor positivo, a pe√ßa tentar√° rotacionar para a direita, enquanto o contr√°rio ocorrer√° para o outro lado. Quando chegamos no if, ele verifica se h√° possibilidade de rotacionar para qualquer lado, se n√£o for poss√≠vel, s√≥ retornamos a posi√ß√£o original (salva na constante "pos"). //
                offset = -(offset + (offset > 0 ? 1 : -1));  
                if (offset > player.matrix[0].length) {  
                    rotate(player.matrix, -dir);  
                    player.pos.x = pos;
                    return;  
                }  
            }  
        }
        function start(){ // Fun√ß√£o para come√ßar o jogo //
            $('#startButton').blur(); // Tiramos o foco do bot√£o //
            document.getElementById('rightSide').style.display = 'block';
            document.getElementById('canva-score').style.display = 'flex';
            arena.forEach((row) => row.fill(0)); // Primeiro limpamos toda a arena para caso houvesse alguma pe√ßa nela (caso seja a segunda vez jogando) //
            playerReset(); // Chamamos a fun√ß√£o que gera pe√ßa //
            update(); // Chamamos a fun√ß√£o que atualiza o jogo a todo instante //
            document.getElementById('gameOverScreen').style.display = 'none'; // Definimos que agora a tela de gameOver deve estar escondida dnv caso seja a segunda vez jogando (ou mais) //
            dropInterval = 500; // Definimos novamente o drop interval para 500 //
            player.score = 0; // O score √© resetado para 0 tamb√©m //
            updateScore(); // Atualizamos o score na tela //
            stopLevelUpdate(); // Pare o intervalo de atualiza√ß√£o do n√≠vel antes de iniciar um novo jogo //
            player.level = 0; // Redefina o n√≠vel do jogador para o valor inicial //
            showLevel(); // Mostramos o lvl atualizado na tela //
            startLevelUpdate(); // Come√ßamos novamente a contar o level //
        }
        function showGameOver() { // S√≥ mostramos a tela de gameOver na tela //
            document.getElementById('gameOverScreen').style.display = 'block';
        }
        // Defina uma vari√°vel para controlar o intervalo de atualiza√ß√£o do n√≠vel
        let levelUpdateInterval; // Vari√°vel que vai armazenar o intervalo que o lvl vai aumentar //

        // Fun√ß√£o para atualizar o n√≠vel do jogador com base no tempo decorrido //
        function updateLevel() {
            player.level++; // Aumenta o n√≠vel do jogador //
            dropInterval -= 20; // Reduz o intervalo de queda para aumentar a velocidade do jogo //
            showLevel(); // Atualiza a exibi√ß√£o do n√≠vel //
        }
        // Fun√ß√£o para iniciar o intervalo de atualiza√ß√£o do n√≠vel //
        function startLevelUpdate() {
            levelUpdateInterval = setInterval(updateLevel, 20000); // Atualiza o n√≠vel a cada 20 segundos //
        }

        // Fun√ß√£o para parar o intervalo de atualiza√ß√£o do n√≠vel (se necess√°rio) //
        function stopLevelUpdate() {
            clearInterval(levelUpdateInterval);
        }

        // Fun√ß√£o para exibir o n√≠vel do jogador //
        function showLevel() {
            let nivelJogador = String(player.level).padStart(3, '0'); // Colocamos 3 zeros na tela //
            document.getElementById("nivel").innerText = "Level: " + nivelJogador; // Adicionamos o lvl atual com a string "Level" //
        }
        function gameOver(nivelJogador) { // Fun√ß√£o que acaba com o jogo (o par√¢metro est√° ai pois foi a √∫nica maneira que consegui incluir o level atual do jogador na datatable) //
            gameOverSound.play(); // Toca o som de fim //
            showGameOver(); // Mostra a tela de game over //
            console.log("Game Over!"); // Console Log //
            dropInterval = 9999999; // Drop Interval infinito pra nao cair nenhuma pe√ßa //
            player.pos.y = -10; // Jogamos as pe√ßas 10 px pra cima do canvas, assim ngm vai ver a pe√ßa ali paradinha //
            stopLevelUpdate() // Paramos a contagem de lvl //
            let playerName = prompt("Digite seu nome:"); // Perguntamos o nome e sobrenome //
            let playerPartnerName = prompt("Digite o seu sobrenome:");

            playerName = playerName.substring(0, 14); // M√°ximo de 14 caracteres para ambos //
            playerPartnerName = playerPartnerName.substring(0, 14);

            const date = new Date().toLocaleDateString(); // Salvamos a data e score atual do jogador //
            const score = player.score;


            addScoreToTable(playerName, playerPartnerName, nivelJogador, score, date);

            saveScoreboardData(); // Salvamos as informa√ß√µes do scoreboard nesta fun√ß√£o //
        }
        function playerHardDrop() { // fun√ß√£o de HardDrop //
            const originalPos = { ...player.pos }; // Copiamos a posi√ß√£o atual do jogador nesta constante //
            while (!collide(arena, player)) { // Enquanto n√£o colidir, aumenta o Y o m√°ximo que conseguir //
                player.pos.y++;
            }
            player.pos.y--; // Voltamos 1 quando colidir //
            if (!collide(arena, player)) { // Como voltamos uma posi√ß√£o, agora enquanto n√£o colidir, podemos mover a pe√ßa para os lados depois de dar hard drop para podermos fazer a jogadinha üòé //
                var moveDelay = 100; // Delay de 100 ms para ser dif√≠cel de fazer a jogadinha //
                let currentTime = performance.now(); // Usamos performance pois como queremos ter uma precis√£o muito exata, o performance √© o √∫nico que consegue entregar tanta precis√£o de resposta //
                let allowMove = true; // Permitimos o movimento //

                const moveHandler = (event) => {
                    if (allowMove) { // Se for permitido o movimento, escreva sua hist√≥ria ü§† //
                        if (event.keyCode === 37) { 
                            playerMove(-1);
                            allowMove = false; 
                        } else if (event.keyCode === 39) { 
                            playerMove(1);
                            allowMove = false; 
                        }
                    }
                };

                document.addEventListener("keydown", moveHandler);

                setTimeout(() => {
                    document.removeEventListener("keydown", moveHandler);
                }, moveDelay);
            }
        }

        function drawGhostPiece() { // Func que ir√° desenhar a pe√ßa fantasma na arena //
            let ghostPiecePosition = { ...player.pos }; // Copia a posi√ß√£o do jogador //
            while (!collide(arena, { matrix: player.matrix, pos: { ...ghostPiecePosition } })) { // Enquanto a pe√ßa copiada do jogador n√£o colidir com a arena, ele incrementa a ghostpiece no eixo y //
                ghostPiecePosition.y++;
            }
            ghostPiecePosition.y--; // Quando colidir, volta 1 posi√ß√£o do eixo Y //

            player.matrix.forEach((row, y) => { // Definimos uma corzinha transparente e escura para a pe√ßa fantasma //
                row.forEach((value, x) => {  
                    if (value !== 0) {
                        context.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        context.fillRect(x + ghostPiecePosition.x, y + ghostPiecePosition.y, 1, 1);
                    }
                });
            });
        }
 
        function addScoreToTable(playerName, playerPartnerName, nivelJogador, score, date) { // Fun√ß√£o para adicionar todas as informa√ß√µes salvas anteriormente na datatable //
            if (scoreboardTable) {
                const deleteButton = `<button class="botao-de-exclusao" onclick="deleteScore(event)"></button>`;
                scoreboardTable.row.add([ // Adiciona essas informa√ß√µes na datatable //
                    playerName,
                    playerPartnerName,
                    nivelJogador,
                    score,
                    date,
                    deleteButton,
                ])  .draw(); 
            }
        }
        function deleteScore(event) { // Fun√ß√£o para apagar a linha da datatable com o botaozinho (essa fun√ß√£o √© chamada no "deleteButton" // 
            const row = event.target.closest('tr'); // Identificamos o TR mais pr√≥ximo e definimos que ele ser√° nossa constante "row" (linha) //
            const rowIndex = scoreboardTable.row(row).index(); // Obt√©m o √≠ndice da linha na tabela
            const data = JSON.parse(localStorage.getItem('scoreboardData')); // Deifinimos que os dados s√£o as informa√ß√µes salvas dentro do JSON localStorage //
            if (data) {
                data.splice(rowIndex, 1); // Remove os dados associados ao √≠ndice da linha
                localStorage.setItem('scoreboardData', JSON.stringify(data));
            }
            scoreboardTable.row(row).remove().draw(); // Removemos a linha //
        }
        function loadScoreboardData() { // Carregamos as informa√ß√µes anteriormente salvas no localStorage //
            const data = localStorage.getItem('scoreboardData'); // Pegamos as info salvas //
            if (data) {
                const scoreboardData = JSON.parse(data);
                scoreboardData.forEach(row => {
                    addScoreToTable(row[0], row[1], row[2], row[3], row[4], row[5]); // Adicionamos elas em local certinho //
                });
            }
        } 
        function saveScoreboardData() { // Fun√ß√£o para salvarmos as informa√ß√µes no localStorage //
            const data = scoreboardTable.rows().data().toArray(); 
            localStorage.setItem('scoreboardData', JSON.stringify(data));
        }
        function showControls() { // Collapse que mostra os comandos //
            controlsBox.style.display = "block";
        }
        let dropCounter = 0; // Vari√°vel que define a contagem de drops em 0 //
        let dropInterval = 1000; // Vari√°vel que define o intervalo de drop das pe√ßas em 1000 ms //
        let lastTime = 0; // Vari√°vel que usaremos para atualizar o jogo //
        function update(time = 0) { // Fun√ß√£o para atualizar o jogo a todo o momento //
            const deltaTime = time - lastTime; // Calcula o intervalo entre o tempo atual e o √∫ltimo atualizado //
            dropCounter += deltaTime; // Adiciona o tempo atualizado com o dropCounter para controlar a velocidade do jogo //
            if (dropCounter > dropInterval) { // Verifica se o valor atualizado excede o valor de queda //
                playerDrop(); // Se sim, cai uma linhazinha
            }  
            lastTime = time; // Atualizamos agora o lastTime como o Time atual para que depois, quando a fun√ß√£o for chamada novamente, sempre salve a atualiza√ß√£o correta //
            draw(); // Atualiza o jogo //
            requestAnimationFrame(update); // Inicializa um loop infinito que sempre atualiza o jogo a todo o instante enquanto estiver em execu√ß√£o // 
        }  
        function updateScore() {  // Atualiza o score na tela //
            let formattedScore = String(player.score).padStart(4, '0');  
            document.getElementById("score").innerText = "Score: " + formattedScore;  
        } 
        
        // Movimenta√ß√£o do jogador //

        document.addEventListener("keydown", (event) => {  
            if (event.keyCode === 37) {  
                playerMove(-1);  
            } 
            else if (event.keyCode === 39) {  
                playerMove(1);  
            } 
            else if (event.keyCode === 40) {  
                playerDrop();  
            } 
            else if (event.keyCode === 65) {  
                playerRotate(-1);  
            } 
            else if (event.keyCode === 68) {  
                playerRotate(1);  
            }  
            else if (event.keyCode === 32) { // Tecla de espa√ßo para hard drop
                playerHardDrop();
                tetrisDrop.play();
            }
        });  
        // Definimmos o quadradinho como 5x5 //
        const arenaNextPiece = createMatrix(5, 5);
        // Definimos a arena como 12x20 //
        const arena = createMatrix(12, 20);  
        // Fazemos todas as varia√ß√µes para o player
        const player = {  
            pos: { x: 0, y: 0 },  
            matrix: null,  
            score: 0,  
            level: 0,
        };
        // Atualizamos o score quando inicia a p√°gina //
        updateScore();
        // Atualizamos o lvl quando inicia a p√°gina //
        showLevel();
    </script>
</body>
</html>